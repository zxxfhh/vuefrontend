<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="150" height="150" viewBox="0 0 150 150" xmlns="http://www.w3.org/2000/svg">
  <!-- Livello acqua con path -->
  <path id="waterShape" fill="#3399ff" d="" />
  <path id="waterShapeBorder" fill="none" stroke="#444444" stroke-width="4" stroke-linecap="round" d="" />
  <circle id="tankBorder" cx="75" cy="75" r="68" stroke="#888888" stroke-width="4" fill="none" />

  <text id="tankText" x="75" y="85" text-anchor="middle" font-size="24" fill="#000000" font-family="Arial">30%</text>

  
  <!-- Static preview (used in <img>) -->
  <clipPath id="clipCirclePreview">
    <circle cx="75" cy="75" r="65"/>
  </clipPath>
  <g id="previewClipGroup" clip-path="url(#clipCirclePreview)">
    <path id="previewWater" fill="#74b1e6" d="M 10 101.0 Q 26.25 97.00, 42.50 101.00 Q 58.75 105.00, 75.00 101.00 Q 91.25 97.00, 107.50 101.00 Q 123.75 105.00, 140.00 101.00 V 140 H 10 Z"/>
    <path id="previewWaterBorder" fill="none" stroke="#3781d8" stroke-width="4" stroke-linecap="round" d="M 10 101.0 Q 26.25 97.00, 42.50 101.00 Q 58.75 105.00, 75.00 101.00 Q 91.25 97.00, 107.50 101.00 Q 123.75 105.00, 140.00 101.00 V 140 H 10 Z"/>
  </g>

<script type="text/javascript">
    <![CDATA[
    (function() {
      // ðŸ”‘ èŽ·å–å½“å‰SVGå…ƒç´ 
      const currentScript = document.currentScript;
      const svgRoot = currentScript ? currentScript.ownerSVGElement || currentScript.closest('svg') : null;

      if (!svgRoot) {
        console.error('æ— æ³•æ‰¾åˆ°SVGæ ¹å…ƒç´ ');
        return;
      }

      // ðŸ”‘ ä½¿ç”¨SVGå†…éƒ¨çš„querySelector
      const getElement = (id) => svgRoot.querySelector('#' + id);

      let initValue = 30;
      //!export-start
      let _pc_borderColor = "#898989ff";
      let _pc_waterColor = "#74b1e6ff";
      let _pc_waterBorderColor = "#3781d8ff";
      let _pc_textColor = "#000000ff";
      let _pn_textSize = 24;
      let _pn_value = initValue;
      let _pn_min = 0;
      let _pn_max = 100;
      //!export-end

      function init() {
        const g = getElement('previewClipGroup');
        if (g) g.style.display = "none";
        const pwb = getElement('previewWaterBorder');
        if (pwb) pwb.style.display = "none";

        const tankBorder = getElement('tankBorder');
        const waterShape = getElement('waterShape');
        const tankText = getElement('tankText');

        if (tankBorder) tankBorder.style.stroke = _pc_borderColor;
        // ðŸŽ¨ ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦å·²æœ‰ç”¨æˆ·è®¾ç½®çš„é¢œè‰²ï¼ˆæ¸å˜æˆ–çº¯è‰²ï¼‰ï¼Œå¦‚æžœæœ‰å°±ä¸è¦†ç›–
        if (waterShape) {
          const currentFill = waterShape.style.fill || waterShape.getAttribute('fill') || '';
          // åªæœ‰åœ¨å¡«å……ä¸ºç©ºæˆ–è€…æ˜¯é»˜è®¤é¢œè‰²æ—¶æ‰åº”ç”¨é»˜è®¤é¢œè‰²
          const isDefaultOrEmpty = !currentFill ||
                                   currentFill === _pc_waterColor ||
                                   currentFill === 'rgb(116, 177, 230)' ||
                                   currentFill === '#74b1e6' ||
                                   currentFill === '#3399ff';
          if (isDefaultOrEmpty) {
            waterShape.style.fill = _pc_waterColor;
          }
        }
        if (tankText) {
          tankText.style.fill = _pc_textColor;
          tankText.style.fontSize = _pn_textSize + 'px';
        }
        updateWaterLevel(_pn_value);
      }

      let animationFrame = null;

      function updateWaterLevel(pct) {
        const shape = getElement('waterShape');
        const shapeBorder = getElement('waterShapeBorder');
        const tankText = getElement('tankText');

        if (!shape || !shapeBorder || !tankText) return;

        const waveAmplitude = 0;
        const borderOffset = 2.5;
        pct = Math.max(_pn_min, Math.min(_pn_max, pct));
        const relativePct = Math.round(((pct - _pn_min) / (_pn_max - _pn_min)) * 100);
        const displayPct = Math.max(0, Math.min(100, relativePct));
        tankText.textContent = displayPct + '%';

      const r = 68;
      const cx = 75;
      const cy = 75;
      const percentage = (pct - _pn_min) / (_pn_max - _pn_min);
      const y = cy + r - (2 * r * percentage);

      const dy = cy - y;
      const clampedDy = Math.max(-r, Math.min(r, dy));
      const dx = Math.sqrt(Math.max(0, r * r - clampedDy * clampedDy));
      const x0 = cx - dx;
      const x1 = cx + dx;

      if (percentage >= 1) {
        const fullShape = [
          `M ${cx - r} ${cy}`,
          `A ${r} ${r} 0 1 0 ${cx + r} ${cy}`,
          `A ${r} ${r} 0 1 0 ${cx - r} ${cy}`,
          'Z'
        ].join(' ');

        const br = r - borderOffset;
        const fullBorder = [
          `M ${cx - br} ${cy}`,
          `A ${br} ${br} 0 1 0 ${cx + br} ${cy}`,
          `A ${br} ${br} 0 1 0 ${cx - br} ${cy}`,
          'Z'
        ].join(' ');

        shape.setAttribute('d', fullShape);
        shapeBorder.setAttribute('d', fullBorder);
      } else {
        const largeArc = (percentage > 0.5) ? 1 : 0;
        const waveY = y + waveAmplitude;
        const yBorder = cy + (r - borderOffset) - (2 * (r - borderOffset) * percentage);
        const waveYBorder = yBorder + waveAmplitude;
        const innerX0 = x0 + (x0 < cx ? borderOffset : -borderOffset);
        const innerX1 = x1 + (x1 > cx ? -borderOffset : borderOffset);
        const waveCount = 4;
        const waveAmp = 3;
        const waveWidth = (x1 - x0) / waveCount;
        let wavePath = `M ${x0} ${waveY}`;
        for (let i = 0; i < waveCount; i++) {
          const xStart = x0 + i * waveWidth;
          const xMid = xStart + waveWidth / 2;
          const xEnd = xStart + waveWidth;
          const yCtrl = waveY + (i % 2 === 0 ? -waveAmp : waveAmp);
          wavePath += ` Q ${xMid} ${yCtrl}, ${xEnd} ${waveY}`;
        }
        wavePath += ` A ${r} ${r} 0 ${largeArc} 1 ${x0} ${waveY} Z`;
        const newD = wavePath;
        let waveBorderPath = `M ${innerX0} ${waveYBorder}`;
        const borderWaveWidth = (innerX1 - innerX0) / waveCount;
        for (let i = 0; i < waveCount; i++) {
          const xStart = innerX0 + i * borderWaveWidth;
          const xMid = xStart + borderWaveWidth / 2;
          const xEnd = xStart + borderWaveWidth;
          const yCtrl = waveYBorder + (i % 2 === 0 ? -waveAmp : waveAmp);
          waveBorderPath += ` Q ${xMid} ${yCtrl}, ${xEnd} ${waveYBorder}`;
        }
        waveBorderPath += ` A ${r - borderOffset} ${r - borderOffset} 0 ${largeArc} 1 ${innerX0} ${waveYBorder} Z`;
        const newDBorder = waveBorderPath;
        shape.setAttribute('d', newD);
        shapeBorder.setAttribute('d', newDBorder);
      }

      // ðŸŽ¨ ä¿®å¤ï¼šç§»é™¤æ¯æ¬¡æ›´æ–°éƒ½é‡ç½®é¢œè‰²çš„ä»£ç  - ä¿ç•™ç”¨æˆ·åœ¨"å›¾æ ‡æ•ˆæžœ"ä¸­è®¾ç½®çš„æ¸å˜è‰²
      // shape.setAttribute('fill', _pc_waterColor); // âŒ æ³¨é‡ŠæŽ‰ï¼Œé¿å…è¦†ç›–ç”¨æˆ·æ¸å˜
      shape.setAttribute('stroke', 'none');
      // shapeBorder.setAttribute('stroke', _pc_waterBorderColor); // âŒ æ³¨é‡ŠæŽ‰ï¼Œé¿å…è¦†ç›–ç”¨æˆ·æ¸å˜
      shape.setAttribute('stroke-width', '0');
      shapeBorder.setAttribute('stroke-width', '4');
      shape.setAttribute('stroke-linecap', 'round');
      shapeBorder.setAttribute('stroke-linecap', 'round');

    }

      let animationTimer = null;

      function putValue(id, value) {
        switch(id) {
          case '_pc_borderColor': _pc_borderColor = value; init(); break;
          case '_pc_waterColor': _pc_waterColor = value; init(); break;
          case '_pc_waterBorderColor': _pc_waterBorderColor = value; init(); break;
          case '_pc_textColor': _pc_textColor = value; init(); break;
          case '_pn_textSize': _pn_textSize = parseInt(value); init(); break;
          case '_pn_value':
            let newValue = parseFloat(value);
            newValue = Math.max(_pn_min, Math.min(_pn_max, newValue));
            const step = newValue > _pn_value ? 0.5 : -0.5;
            const delay = 10;

            const animateStep = () => {
              if (_pn_value === newValue) {
                animationTimer = null;
                return;
              }
              _pn_value += step;
              updateWaterLevel(_pn_value);
              animationTimer = setTimeout(animateStep, delay);
            };

            if (animationTimer !== null) clearTimeout(animationTimer);
            if (_pn_value !== newValue) animateStep();
            break;
        }
      }

      // ðŸ”‘ å…³é”®ï¼šå°†å‡½æ•°å’Œå˜é‡æ³¨å†Œåˆ°SVGå…ƒç´ æœ¬èº«
      svgRoot.__svgInstance = {
        putValue: putValue,
        updateWaterLevel: updateWaterLevel,
        getValue: () => _pn_value,
        initValue: initValue,
        _pn_value: _pn_value,
        _pn_min: _pn_min,
        _pn_max: _pn_max
      };

      setTimeout(() => {
        init();
      }, 100);
    })();
    ]]>

  </script>
</svg>
