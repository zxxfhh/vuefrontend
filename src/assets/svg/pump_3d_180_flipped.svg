<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" xml:space="preserve"><desc>Copyright Opto 22</desc> 
<g style="transform-origin: 0px 0px" transform="translate(100,0) rotate(0) scale(-1,1)">
	<g id="frame">
		<rect fill="none" width="100" height="100"></rect>
	</g>

<g id="shape">
	<circle fill="#006837" cx="50.042" cy="50" r="35.208"></circle>
	<rect x="50" y="14.833" fill="#006837" width="50" height="16"></rect>
	<path fill="#006837" d="M50,57.667H0v-16h50c4.418,0,8,3.582,8,8S54.418,57.667,50,57.667z"></path>
	<path fill="#006837" d="M8,60.667H0v-22h8"></path>
	<rect x="92" y="11.833" fill="#006837" width="8" height="22"></rect>
</g>
<g id="dark">
	<path fill="#009245" d="M50.042,15.875c-15.971,0-29.376,10.974-33.096,25.792H50c4.418,0,8,3.582,8,8s-3.582,8-8,8H16.792
		c3.48,15.153,17.04,26.458,33.25,26.458c18.847,0,34.125-15.278,34.125-34.125C84.167,31.153,68.888,15.875,50.042,15.875z"></path>
	<path fill="#009245" d="M50,56.667c3.866,0,7-3.134,7-7s-3.134-7-7-7H0v14C0,56.667,50,56.667,50,56.667z"></path>
	<g>
		<path fill="#009245" d="M50,15.833v0.043c0.014,0,0.028-0.001,0.042-0.001c11.301,0,21.314,5.497,27.524,13.958H100v-14H50z"></path>
	</g>
	<rect x="50" y="15.833" fill="#009245" width="50" height="14"></rect>
</g>
<g id="light">
	<path fill="#96D48D" d="M61.443,17.833c5.692,2.018,10.685,5.502,14.533,10H100v-10H61.443z"></path>
	<g>
		<path fill="#96D48D" d="M50,44.667H0v10c0,0,50,0,50,0c2.761,0,5-2.239,5-5C55,46.905,52.761,44.667,50,44.667z"></path>
	</g>
</g>
<g id="shadow">
	<path fill="#006837" d="M50.042,21.292c-12.932,0-23.891,8.597-27.47,20.375h1.045c3.546-11.219,14.05-19.375,26.425-19.375
		C65.32,22.292,77.75,34.722,77.75,50S65.32,77.708,50.042,77.708c-12.619,0-23.286-8.482-26.621-20.041h-1.04
		c3.363,12.118,14.486,21.041,27.66,21.041C65.871,78.708,78.75,65.83,78.75,50S65.871,21.292,50.042,21.292z"></path>
	<path fill="#006837" d="M50.042,35.792c-4.72,0-8.898,2.323-11.483,5.875h1.247c2.424-2.972,6.111-4.875,10.236-4.875
		c7.283,0,13.208,5.925,13.208,13.208s-5.926,13.208-13.208,13.208c-4.423,0-8.336-2.193-10.734-5.541h-1.209
		c2.53,3.928,6.933,6.541,11.943,6.541c7.834,0,14.208-6.374,14.208-14.208C64.25,42.166,57.876,35.792,50.042,35.792z"></path>
	<polygon fill="#006837" points="51.463,16.488 52.426,18.155 51.463,19.823 49.537,19.823 48.574,18.155 49.537,16.488 	"></polygon>
	<polygon fill="#006837" points="51.463,37.488 52.426,39.155 51.463,40.823 49.537,40.823 48.574,39.155 49.537,37.488 	"></polygon>
	<polygon fill="#006837" points="51.463,58.988 52.426,60.655 51.463,62.323 49.537,62.323 48.574,60.655 49.537,58.988 	"></polygon>
	<polygon fill="#006837" points="58.847,53.613 60.773,53.613 61.735,55.28 60.773,56.948 58.847,56.948 57.884,55.28 	"></polygon>
	<polygon fill="#006837" points="57.884,44.53 58.847,42.863 60.773,42.863 61.735,44.53 60.773,46.198 58.847,46.198 	"></polygon>
	<polygon fill="#006837" points="51.463,80.238 52.426,81.905 51.463,83.573 49.537,83.573 48.574,81.905 49.537,80.238 	"></polygon>
	<polygon fill="#006837" points="34.563,20.5 36.23,21.463 36.23,23.389 34.563,24.351 32.895,23.389 32.895,21.463 	"></polygon>
	<polygon fill="#006837" points="66.438,75.709 68.105,76.672 68.105,78.598 66.438,79.56 64.77,78.598 64.77,76.672 	"></polygon>
	<polygon fill="#006837" points="21.933,32.425 23.858,32.425 24.821,34.093 23.858,35.76 21.933,35.76 20.97,34.093 	"></polygon>
	<polygon fill="#006837" points="77.142,64.3 79.067,64.3 80.03,65.968 79.067,67.635 77.142,67.635 76.179,65.968 	"></polygon>
	<polygon fill="#006837" points="80.707,49.067 82.375,48.105 84.043,49.067 84.043,50.993 82.375,51.956 80.707,50.993 	"></polygon>
	<polygon fill="#006837" points="20.97,65.968 21.933,64.3 23.858,64.3 24.821,65.968 23.858,67.635 21.933,67.635 	"></polygon>
	<polygon fill="#006837" points="76.179,34.093 77.142,32.425 79.067,32.425 80.03,34.093 79.067,35.76 77.142,35.76 	"></polygon>
	<polygon fill="#006837" points="32.895,78.598 32.895,76.672 34.563,75.709 36.23,76.672 36.23,78.598 34.563,79.56 	"></polygon>
	<polygon fill="#006837" points="64.77,23.389 64.77,21.463 66.438,20.5 68.105,21.463 68.105,23.389 66.438,24.351 	"></polygon>
</g>
<g id="hlight">
	<path fill="#FFFFFF" d="M50,53.167H0v-7h50c1.933,0,3.5,1.567,3.5,3.5C53.5,51.6,51.933,53.167,50,53.167z"></path>
	<path fill="#FFFFFF" d="M67.332,19.333c3.289,1.858,6.254,4.223,8.777,7H100v-7H67.332z"></path>
</g>
</g>

  <script type="text/javascript">
    <![CDATA[
    /*
    #####################################
    #           How to Use              #
    #####################################

    Variables with the following prefix:

    _pb_ = bool   parameter ( true or false )
    _pn_ = number parameter ( Int, Float, Real etc )
    _ps_ = string parameter ( string can be entered directly )
    _pc_ = color parameter in hex color code ( #00ff00ff )

    Indicate variable type to be used in Fuxa Properties and binding of Tags, Important! they have to be place within:

    //!export-start
    let _pn_setState = 0;
    //!export-end

  

    There are 2x Functions to handle sending and receiving data between Fuxa and the SVG

    // Recieve Variables From Fuxa
    function putValue(id, value) { } 
    
    // Send Variables To Fuxa
    function postValue(id, value) {
      console.error('Not defined!');
    }

    The ID is the name of the variable _pn_setState for example and value is the value to be sent or received from Fuxa


    This SVG uses an INT/Number Variable to change the State and State of the SVG:

    0 = Off
    1 = Run
    2 = Warning
    3 = Fault
    4 = Invalid
    5 = Spare

    You can also use the bool field and this will change the state between 0 = off and 1 = run 

    You can also set the color for each state in Fuxa using HEX color code #b4b4b4
    The Default Blink Interval is 500ms but can also be changed in Fuxa in MS resolution


    This SVG is a bit complex as we have different shades of color, we calculate the offset colors
    The Shade Values are from -100 to 100, where 0 is not changed and -100 is black and 100 is white

    These style of SVGs can be found here:

    https://www.opto22.com/support/resources-tools/demos/svg-image-library

    By Adding this script to there downloaded SVG it should work without any modification ( may have to check group element names )
    Make sure the script is within the SVG tags

    <svg>
      SVG Content Here
      <script>
        JS Script Content Here
      </script>
    </svg>

    */

	  // Global Parameters and Variables
    //!export-start
    let _pn_setState         = 0;
    let _pb_boolState        = false;
	  let _pn_setInterval      = 500;
    let _pc_state0Colour     = '#b4b4b4';
    let _pc_state1Colour     = '#00ff00';
    let _pc_state2Colour     = '#ff9500';
    let _pc_state3Colour     = '#ff0000';
    let _pc_state4Colour     = '#3c3c3c';
    let _pc_state5Colour     = '#dcdcdc';
    let _pn_lightShade       = 50;
    let _pn_highLightShade   = 90;
    let _pn_darkShade        = 15;
    let _pn_shadowShade      = -15;
    //!export-end
	  let stateNumber = 0;
    let blinkInterval;

    // Function to update the color based on the set state
    function logic() {

      switch (stateNumber) {
        case 0: // off
          setBaseColor( _pc_state0Colour);
		      clearBlinking();
          break; 
        case 1: // run
          setBaseColor( _pc_state1Colour);
		      clearBlinking();
          break;
        case 2: // warning
          setBaseColor( _pc_state2Colour);
		      clearBlinking();
          break;
        case 3: // fault
		      startBlinking( _pc_state0Colour, _pc_state3Colour, _pn_setInterval );
          break;
        case 4: // invalid 
          setBaseColor( _pc_state4Colour);
		      clearBlinking();
          break;
        case 5: // spare
          setBaseColor( _pc_state5Colour);
		      clearBlinking();
          break;
        default:
          console.log('Undefined State');
		      clearBlinking();
      }
    }

    // Initial setup
    function init() {
      logic(); // Initial state rendering
    }

    // Function to update values from Fuxa
    function putValue(id, value) {
      if (id === '_pn_setState') {
        stateNumber = value;
        logic(); 
      }
      if (id === '_pb_boolState') {
        _pb_boolState = value;
        if (_pb_boolState === true) {
          stateNumber = 1;
        } else if (_pb_boolState === false) {
          stateNumber = 0;
        }
        logic(); 
      }
	    if (id === '_pn_setInterval'   ) _pn_setInterval    = value;
      if (id === '_pc_state0Colour'  ) _pc_state0Colour   = value;
      if (id === '_pc_state1Colour'  ) _pc_state1Colour   = value;
      if (id === '_pc_state2Colour'  ) _pc_state2Colour   = value;
      if (id === '_pc_state3Colour'  ) _pc_state3Colour   = value;
      if (id === '_pc_state4Colour'  ) _pc_state4Colour   = value;
      if (id === '_pc_state5Colour'  ) _pc_state5Colour   = value;
      if (id === '_pn_lightShade'    ) _pn_lightShade     = value;
      if (id === '_pn_highLightShade') _pn_highLightShade = value;
      if (id === '_pn_darkShade'     ) _pn_darkShade      = value;
      if (id === '_pn_shadowShade'   ) _pn_shadowShade    = value;
    }

    // Function to send values back to Fuxa (placeholder)
    function postValue(id, value) {
      console.error('Not defined!');
    }

    // Initialize the SVG
    init();

	// Function to update the color for the base shape group
    function setBaseColor(baseColor) {
      // Define color manipulations based on base color
      const darkColor   = percentColor(baseColor, _pn_darkShade);
      const shadowColor = percentColor(baseColor, _pn_shadowShade);
      const lightColor  = percentColor(baseColor, _pn_lightShade);
      const hlightColor = percentColor(baseColor, _pn_highLightShade);

	  document.getElementById('shape').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', baseColor);
      });
      document.getElementById('dark').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', darkColor);
      });
      document.getElementById('shadow').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', shadowColor);
      });
      document.getElementById('light').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', lightColor);
      });
	  document.getElementById('hlight').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', hlightColor);
      });
	}

    // Function to manipulate color brightness/darkness (-100% = Black) (0 = unchanged) (100% = White)
    function percentColor(color, percent) {
      let R = parseInt(color.substring(1, 3), 16);
      let G = parseInt(color.substring(3, 5), 16);
      let B = parseInt(color.substring(5, 7), 16);

      // Calculate the adjustment factor based on the percentage
      if (percent > 0) {
          // Lightening - move each channel closer to 255 (white)
          R = Math.round(R + (255 - R) * (percent / 100));
          G = Math.round(G + (255 - G) * (percent / 100));
          B = Math.round(B + (255 - B) * (percent / 100));
      } else {
          // Darkening - move each channel closer to 0 (black)
          R = Math.round(R * (1 + (percent / 100)));
          G = Math.round(G * (1 + (percent / 100)));
          B = Math.round(B * (1 + (percent / 100)));
      }

      // Clamp values to the [0, 255] range
      R = Math.max(0, Math.min(255, R));
      G = Math.max(0, Math.min(255, G));
      B = Math.max(0, Math.min(255, B));

      // Convert back to hexadecimal
      const RR = (R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16);
      const GG = (G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16);
      const BB = (B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16);

      return "#" + RR + GG + BB;
    }

	// Function to start blinking between two colors
    function startBlinking(color1, color2, interval) {
      clearBlinking(); // Clear any existing blinking interval
    
      let isColor1 = true; 
      blinkInterval = setInterval(function() {
        const checkDestroy = document.getElementById('Layer_1'); // Important must be name of the SVG!
        if (!checkDestroy) {
          clearBlinking(); 
          return;
        }
        if (isColor1) {
          setBaseColor(color1); 
        } else {
          setBaseColor(color2); 
        }
        isColor1 = !isColor1; 
      }, interval);

      // Set up the MutationObserver to watch for removal of the SVG element
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            if (node.id === 'Layer_1') { // Important must be name of the SVG!
              clearBlinking(); 
              observer.disconnect(); 
            }
          });
        });
      });

      // Start observing the body or a parent element of the SVG
      observer.observe(document.body, { childList: true, subtree: true }); 
    }

    // Function to clear the blinking interval
    function clearBlinking() {
      if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
      }
    }

    ]]>
  </script>

</svg>