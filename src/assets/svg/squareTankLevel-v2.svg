<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="150" height="150" viewBox="0 0 150 150" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
  <!-- Livello acqua con path -->
  <path id="waterShape" fill="#3399ff" d="" stroke-width="1" />
  <path id="waterShapeBorder" fill="none" stroke="#444444" stroke-width="4" stroke-linecap="round" d="" />
  <rect id="tankBorder" x="7" y="7" width="136" height="136" stroke="#888888" stroke-width="4" fill="none" />

  <!-- Static preview (used in <img>) -->
  <path id="previewWater" fill="#74b1e6" d="M9 70 Q42 66, 75 70 Q108 74, 141 70 V141 H9 Z"/>

  <text id="tankText" x="75" y="85" text-anchor="middle" font-size="24" fill="#000000" font-family="Arial">30%</text>

  <script type="text/javascript">
    <![CDATA[
    (function() {
      // ğŸ”‘ è·å–å½“å‰SVGå…ƒç´ 
      const currentScript = document.currentScript;
      const svgRoot = currentScript ? currentScript.ownerSVGElement || currentScript.closest('svg') : null;

      if (!svgRoot) {
        console.error('æ— æ³•æ‰¾åˆ°SVGæ ¹å…ƒç´ ');
        return;
      }

      // ğŸ”‘ ä½¿ç”¨SVGå†…éƒ¨çš„querySelector
      const getElement = (id) => svgRoot.querySelector('#' + id);

      let initValue = 30;
      //!export-start
      let _pc_borderColor = "#898989ff";
      let _pc_waterColor = "#74b1e6ff";
      let _pc_waterBorderColor = "#3781d8ff";
      let _pc_textColor = "#000000ff";
      let _pn_textSize = 24;
      let _pn_value = initValue;
      let _pn_min = 0;
      let _pn_max = 100;
      //!export-end

      function init() {
        const pw = getElement('previewWater');
        if (pw) pw.style.display = "none";

        const tankBorder = getElement('tankBorder');
        const waterShape = getElement('waterShape');
        const tankText = getElement('tankText');

        if (tankBorder) tankBorder.style.stroke = _pc_borderColor;
        // ğŸ¨ ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦å·²æœ‰ç”¨æˆ·è®¾ç½®çš„é¢œè‰²ï¼ˆæ¸å˜æˆ–çº¯è‰²ï¼‰ï¼Œå¦‚æœæœ‰å°±ä¸è¦†ç›–
        if (waterShape) {
          const currentFill = waterShape.style.fill || waterShape.getAttribute('fill') || '';
          // åªæœ‰åœ¨å¡«å……ä¸ºç©ºæˆ–è€…æ˜¯é»˜è®¤é¢œè‰²æ—¶æ‰åº”ç”¨é»˜è®¤é¢œè‰²
          const isDefaultOrEmpty = !currentFill ||
                                   currentFill === _pc_waterColor ||
                                   currentFill === 'rgb(116, 177, 230)' ||
                                   currentFill === '#74b1e6' ||
                                   currentFill === '#3399ff';
          if (isDefaultOrEmpty) {
            waterShape.style.fill = _pc_waterColor;
          }
        }
        if (tankText) {
          tankText.style.fill = _pc_textColor;
          tankText.style.fontSize = _pn_textSize + 'px';
        }
        updateWaterLevel(_pn_value);
      }

      let animationFrame = null;

      function updateWaterLevel(pct) {
        const shape = getElement('waterShape');
        const shapeBorder = getElement('waterShapeBorder');
        const tankText = getElement('tankText');

        if (!shape || !shapeBorder || !tankText) return;

        pct = Math.max(_pn_min, Math.min(_pn_max, pct));
        const relativePct = Math.round(((pct - _pn_min) / (_pn_max - _pn_min)) * 100);
        const displayPct = Math.max(0, Math.min(100, relativePct));
        tankText.textContent = displayPct + '%';

        const x = 9;
        const y = 9;
        const width = 132;
        const height = 132;
        const fillHeight = height * (pct - _pn_min) / (_pn_max - _pn_min);
        const topY = y + height - fillHeight;

        const waveCount = 4;
        const waveAmp = 4;
        const waveWidth = width / waveCount;

        let wavePath = `M ${x} ${topY}`;
        for (let i = 0; i < waveCount; i++) {
          const xStart = x + i * waveWidth;
          const xMid = xStart + waveWidth / 2;
          const xEnd = xStart + waveWidth;
          const yCtrl = topY + (i % 2 === 0 ? -waveAmp : waveAmp);
          wavePath += ` Q ${xMid} ${yCtrl}, ${xEnd} ${topY}`;
        }
        wavePath += ` V ${y + height} H ${x} Z`;

        let waveBorderPath = `M ${x} ${topY}`;
        for (let i = 0; i < waveCount; i++) {
          const xStart = x + i * waveWidth;
          const xMid = xStart + waveWidth / 2;
          const xEnd = xStart + waveWidth;
          const yCtrl = topY + (i % 2 === 0 ? -waveAmp : waveAmp);
          waveBorderPath += ` Q ${xMid} ${yCtrl}, ${xEnd} ${topY}`;
        }
        waveBorderPath += ` V ${y + height} H ${x} Z`;

        shape.setAttribute('d', wavePath);
        shapeBorder.setAttribute('d', waveBorderPath);

        // ğŸ¨ ä¿®å¤ï¼šç§»é™¤æ¯æ¬¡æ›´æ–°éƒ½é‡ç½®é¢œè‰²çš„ä»£ç  - ä¿ç•™ç”¨æˆ·åœ¨"å›¾æ ‡æ•ˆæœ"ä¸­è®¾ç½®çš„æ¸å˜è‰²
        // shape.setAttribute('fill', _pc_waterColor); // âŒ æ³¨é‡Šæ‰,é¿å…è¦†ç›–ç”¨æˆ·æ¸å˜
        // shape.setAttribute('stroke', _pc_waterColor); // âŒ æ³¨é‡Šæ‰,é¿å…è¦†ç›–ç”¨æˆ·æ¸å˜
        shape.setAttribute('stroke-width', '1');
        // shapeBorder.setAttribute('stroke', _pc_waterBorderColor); // âŒ æ³¨é‡Šæ‰,é¿å…è¦†ç›–ç”¨æˆ·æ¸å˜
        shapeBorder.setAttribute('stroke-width', '4');
        shape.setAttribute('stroke-linecap', 'round');
        shapeBorder.setAttribute('stroke-linecap', 'round');
      }

      let animationTimer = null;

      function putValue(id, value) {
        switch(id) {
          case '_pc_borderColor': _pc_borderColor = value; init(); break;
          case '_pc_waterColor': _pc_waterColor = value; init(); break;
          case '_pc_waterBorderColor': _pc_waterBorderColor = value; init(); break;
          case '_pc_textColor': _pc_textColor = value; init(); break;
          case '_pn_textSize': _pn_textSize = parseInt(value); init(); break;
          case '_pn_value':
            let newValue = parseFloat(value);
            newValue = Math.max(_pn_min, Math.min(_pn_max, newValue));
            const step = newValue > _pn_value ? 0.5 : -0.5;
            const delay = 10;

            const animateStep = () => {
              if (_pn_value === newValue) {
                animationTimer = null;
                return;
              }
              _pn_value += step;
              updateWaterLevel(_pn_value);
              animationTimer = setTimeout(animateStep, delay);
            };

            if (animationTimer !== null) clearTimeout(animationTimer);
            if (_pn_value !== newValue) animateStep();
            break;
        }
      }

      // ğŸ”‘ å…³é”®ï¼šå°†å‡½æ•°å’Œå˜é‡æ³¨å†Œåˆ°SVGå…ƒç´ æœ¬èº«
      svgRoot.__svgInstance = {
        putValue: putValue,
        updateWaterLevel: updateWaterLevel,
        getValue: () => _pn_value,
        initValue: initValue,
        _pn_value: _pn_value,
        _pn_min: _pn_min,
        _pn_max: _pn_max
      };

      setTimeout(() => {
        init();
      }, 100);
    })();
    ]]>
  </script>
</svg>
